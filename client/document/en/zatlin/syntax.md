<!-- title: Complete specification -->


## Basic syntax
In Zatlin, one describes what forms of strings to generate by using a syntax called ‘pattern’.
The syntax of patterns will be explained in detail later.

A main pattern is defined by writing `%` followed by the pattern and putting `;` at the end.
A processor of Zatlin will output strings randomly along the main pattern, and thus specifying the main pattern is mandatory.
```zatlin-try
% "s" | "t" | "k";
```

A variable is defined by putting the name, the symbol `=`, a pattern and finally `;` in this order.
The variable name must consist of alphanumeric letters or `_`’s and not start with a digit.
Variables can be used in other patterns.
The order in which variables are defined does not change the behaviour, and thus variables defined in a later line can be used beforehand.
```zatlin-try
vowel = "a" | "e" | "i";
cons = "s" | "t" | "k";
last_cons = "z" | "d";
pattern = cons vowel last_cons;
% pattern;
```

A text between `#` and the end of the line is treated as a comment and does not affect the processing behaviour.
```zatlin-try
# ここはコメント
% ("s" | "t" | "k") ("a" | "e" | "i") ("z" | "d");  # コメント
# ここはコメント
```

Only `;` at the end of a line or just before a comment can be omitted.
```zatlin-try
foo = "a" | "b"  # ← 省略可能
bar = "c" | "d"; baz = "e" | "f"  # 行中 (baz の直前) は省略できない
% foo
```

## Patterns
### String patterns
A string enclosed in `"` is a string pattern.
A string pattern always generates itself.
```zatlin-try
% "abc";
# 「abc」という文字列が必ず生成される
```

If one wants to use the character `"` in a string pattern, it must be prefixed with a backslash to escape it as `\"`.
Similarly, if one wants to use the character `\`, escape it as `\\`.
```zatlin-try
% "\"\\n\"";
# 「"\n"」という文字列が必ず生成される
```

In a string pattern, `\u` followed by a four-digit hexadecimal number can be used to represent the character with that Unicode codepoint.
This is useful for describing special characters that are difficult to type directly.
```zatlin-try
% "\u00E9";
# 「é」という文字列が必ず生成される
```

### Variable patterns
A variable name can be used as a variable pattern.
A variable pattern produces a string which is generated by the pattern assigned to the variable.
```zatlin-try
foo = "abc";  # 変数 foo の定義
# foo は「abc」という文字列を必ず生成する文字列パターン
% foo;
# foo と同じく「abc」という文字列が必ず生成される
```

When a variable pattern with the same name is used more than once in a pattern, the string will be regenerated each time for each variable pattern.
Therefore, a variable pattern with the same name does not always produce the same string.
If one wants to generate a string that is identical to the string generated by the previous pattern, use backreference patterns.
```zatlin-try
foo = "a" | "b";
% foo foo;
# 「aa」か「ab」か「ba」か「bb」が等確率で生成される
# 同名の変数パターンだからといって「aa」と「bb」だけが生成されるわけではない
```

### Sequence patterns
A sequence of patterns separated by spaces is a sequence pattern.
A sequence pattern generates the string which is obtained by concatenating the strings generated by the patterns constituting the sequence pattern.
```zatlin-try
foo = "a" | "b";
# foo は「a」か「b」を等確率で生成する
% foo "x";
# foo によって文字列を生成した後に「x」を結合した文字列を生成する
# 結果的に「ax」か「bx」が等確率で生成される
```

When an element of a sequence pattern is a disjunction pattern or a compound pattern, it is necessary enclose it with `(` and `)`.
```zatlin-try
% ("a" | "b") "x" ("c" | "d");  # 3 つの要素からなる連続パターン
# 「axc」か「axd」か「bxc」か「bxd」が等確率で生成される
```

### Backreference patterns
A symbol `&` followed by an integer can be used as a backreference pattern to refer a previous pattern.
For example, `&1` produces the string identical to that produced by the first pattern in the sequence pattern.
```zatlin-try
foo = "a" | "b";
% foo &1;
# 「aa」か「bb」が等確率で生成される
```

Note that the pattern to which the backreference pattern refers must precede it.
For example, since `&2` refers to the second pattern, `&2` itself can only be placed after the second pattern in a sequence.
If a backreference pattern is placed anywhere else, the error #2001 will occur.
```zatlin-try
foo = "a" | "b";
% foo &2 ("x" | "y");  # エラー
```

### Disjunction patterns
When the patterns are arranged separated by `|`, they are treated as a disjunction pattern.
A disjunction pattern chooses one of the patterns in itself with equal probability, and produces the string generated by the chosen pattern.
```zatlin-try
% "a" | "b" | "c";
# 「a」か「b」か「c」が等確率で生成される
```

When a number is placed after a pattern which constitutes a disjunction pattern, it becomes more likely to be selected according to the number.
For example, putting `2` makes the pattern twice as likely to be selected as the others.
Placing `0.5` makes the pattern a half times as likely to be selected, resulting in making it less likely to be choosen.
```zatlin-try
% "a" 3 | "b" 2 | "c";
# 「a」は 3 倍,「b」は 2 倍生成されやすくなる
# 結果的に 1/2 の確率で「a」, 1/3 の確率で「b」, 1/6 の確率で「c」が生成される
```

### Compound patterns
A disjunction pattern followed by `-` and then another pattern is a compund pattern.
A compound pattern first generates a string according to the disjunction pattern, but when the generated string contains a string that can be generated by the pattern after `-`, it regenerates a string again from the the disjunction pattern.
As a consequence, the strings that contain those generated by the pattern after `-` are excluded from the strings generated by the entire compound pattern.
The pattern written after `-` is called an ‘exclusion pattern’.
```zatlin-try
% "abc" | "pqr" | "xyz" - "p";
# 「abc」と「pqr」と「xyz」のいずれかが等確率で生成された後で
# それが「p」を含む「pqr」だった場合はもう一度生成し直す
# 結果的に「pqr」はこのパターンから生成されずに「abc」か「xyz」が等確率で生成される
```

Regeneration from the disjunction pattern is performed up to 100 times.
When, after 100 regenerations, no string is obtained which is not excluded, the error #2000 will occur.
This happens, for example, when all possible patterns are excluded.
```zatlin-try
% "ab" | "ac" | "bc" - "a" | "c";
# 前半部分で生成され得る「ab」か「ac」か「bc」はいずれも「a」と「c」を含んでいる
# したがって常に再生成が試みられる
# 結果的に複合パターンからの生成に失敗してエラーになる
```

Moreover, a non-excluded string is very unlikely to be generated, it may fail with the error #2000.
```zatlin-try
% "a" 1000000 | "b" 1 - "a";
# 1/1000001 の確率で除外設定されていない「b」が生成され得る
# しかし「b」の確率が非常に低いので 100 回の試行ではほとんど生成されない
# 結果的にほとんど必ずエラーになる
```

### Boundary patterns
In the exclusion part of a compound pattern, the special symbol `^` can be used.
When `^` is put at the beginning of a sequence pattern, only strings starting with those which the sequence pattern could produce are excluded.
Remember that, without `^`, all strings containing those which the sequence pattern could produce are excluded.
```zatlin-try
% "ab" | "ba" | "ca" - ^ "a" | "c";
# 「a」で始まるものか「c」を含むものが除外される
# 結果的に「ba」だけが生成される
```

When `^` is placed at the end of a sequence pattern, only strings ending with those which the sequence pattern could produce are excluded.
```zatlin-try
% "ab" | "ba" | "ca" - "a" ^;
# 「a」で終わるものが除外される
# 結果的に「ab」だけが生成される
```

When `^` is put at both the beginning and the end of a sequence pattern, only strings which exactly matches those generatable by the sequence pattern will be excluded.
```zatlin-try
% "a" | "aa" | "aaa" - ^ "a" ^;
# 「a」のみが除外される
# 結果的に「aa」と「aaa」が等確率で生成される
```

The behaviour of `^` may be easy to understand if one thinks it matches the boundary before or after a string in checking whether or not the generated string is excluded.

Since any pattern can be written in the exclusion part of a compound pattern, variable patterns can also be used.
One can define a variable containing `^` to use it in the exclusion part of a compound pattern.
```zatlin-try
start_with_vowel = ^ ("a" | "e" | "i" | "o" | "u");
% "abc" | "def" | "ijk" | "uvw" - start_with_vowel;
# 「def」のみが生成される
```

Note that `^` can only be put at the beginning or the end of a sequence pattern.
Placing it anywhere else (such as inside a sequence pattern) will result in a syntax error.
```zatlin-try
% "abc" | "bac" | "cab" - "a" ^ "c";  # 構文エラー
```

The symbol `^` can also be written outside the exclusion part of a compound pattern, in which case it is simply ignored.
```zatlin-try
% ^ "a" | "b" "c" ^;
# 「a」と「bc」が等確率で生成される
```

## Formal syntax
The following is the syntax of Zatlin written in the extended BNF notation, where `zatlin` is the entire definition of Zatlin code.
```bnf
zatlin ::= blank_or_break sentence+ eof
sentence ::= definition | main_pattern | comment
definition ::= identifier blank '=' blank compound blank semicolon
main_pattern ::= '%' blank compound blank semicolon
compound ::= disjunction blank ('-' blank disjunction)?
disjunction ::= weighted_sequence (blank '|' blank weighted_sequence)*
weighted_sequence ::= sequence (blank weight)?
sequence ::= circumflex? blank sequence_pattern blank circumflex?
sequence_pattern ::= quote | backref | identifier | '(' blank compound blank ')'
quote ::= '"' (quote_escape | quote_content)* '"'
quote_escape ::= '\\' ('u' [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] | '\\' | '"')
quote_content ::= [^\\"]
backref ::= '&' [0-9]+
circumflex ::= '^'
comment ::= '#' [^\n]* blank_or_break
semicolon ::= ';' blank_or_break | break blank_or_break | comment
identifier ::= [a-zA-Z] [a-zA-Z0-9_]*
weight ::= [0-9]+ '.'? [0-9]* | '.' [0-9]+
blank_or_break ::= [\s]* eof?
blank ::= [^\S\n]*
break ::= '\n' | eof
```

The extensions used here are as follows:

- `foo*` — zero or more repetitions of `foo`
- `foo+` — one or more repetitions of `foo`
- `foo?` — zero or one repetition of `foo` (`foo` can be omitted)
- `[0-9]` etc — character class of regular expression