## Zatlin とは
執筆中です。

## 基本構文
Zatlin では、どのような様式の文字列を生成するかを「パターン」と呼ばれる構文で表現します。
パターンの構文については、後で詳しく解説します。

`%` に続いてパターンを書き、最後に `;` を置くと、メインパターンを定義できます。
Zatlin の処理系はこのメインパターンに沿ってランダムに文字列を出力するため、必ずメインパターンを書く必要があります。
```zatlin
% "s" | "t" | "k";
```

変数名に続いて `=` を書き、さらにパターンを続けて最後に `;` を置くと、変数を定義することができます。
変数名としては、英数字か `_` から構成される文字列であって、先頭が数字でないものが利用できます。
定義した変数は別のパターンの中で使用することができます。
変数を定義する順番によって動作が変化することはなく、後の行で定義される変数を使うこともできます。
```zatlin
cons = "s" | "t" | "k";
vowel = "a" | "e" | "i"
last_cons = "z" | "d";
pattern = consonant vowel last_cons;
% pattern;
```

`#` から行末まではコメントとして扱われ、処理に影響を与えません。
```zatlin
# ここはコメント
% ("s" | "t" | "k") ("a" | "e" | "i") ("z" | "d");  # コメント
# ここはコメント
```

行末もしくはコメントの直前の `;` に限り省略できます。
```zatlin
foo = "a" | "b"  # ← 省略可能
bar = "c" | "d"; baz = "e" | "f"  # 行中 (baz の直前) は省略できない
% foo
```

## パターン
### 文字列パターン
`"` で囲まれた文字列は文字列パターンになります。
文字列パターンは、常にその文字列自身を生成します。
```zatlin
% "abc";
# 「abc」という文字列が必ず生成される
```

文字列パターン内で `"` という文字を使いたい場合は、バックスラッシュを前置して `\"` とエスケープしてください。
また、`\` という文字を使いたい場合も、`\\` とエスケープしてください。
```zatlin
% "\"\\n\"";
# 「"\n"」という文字列が必ず生成される
```

文字列パターン内で `\u` に続いて 16 進 4 桁の数を続けることで、その Unicode コードポイントの文字を表すことができます。
直接入力しづらい特殊文字を記述するのに便利です。
```zatlin
% "\u00E9";
# 「é」という文字列が必ず生成される
```

### 変数パターン
変数名はそのまま変数パターンとして使うことができます。
変数パターンは、その変数に定義されているパターンが生成する文字列と同様の文字列を生成します。
```zatlin
foo = "abc";  # 変数 foo の定義
# foo は「abc」という文字列を必ず生成する文字列パターン
% foo;
# foo と同じく「abc」という文字列が必ず生成される
```

1 つのパターンの中で同名の変数パターンが複数回使われた場合、その変数パターンごとに毎回文字列を生成し直します。
したがって、同名の変数パターンが常に同一の文字列を生成するとは限りません。
前に出てくるパターンが生成した文字列と同一の文字列を生成したい場合は、後方参照パターンを利用してください。
```zatlin
foo = "a" | "b";
% foo foo;
# 「aa」か「ab」か「ba」か「bb」が等確率で生成される
# 同名の変数パターンだからといって「aa」と「bb」だけが生成されるわけではない
```

### 連続パターン
パターンをスペースで区切って並べると連続パターンになります。
連続パターンは、それを構成するパターンに従って順番に文字列を生成し、その結果を順に結合した文字列を生成します。
```zatlin
foo = "a" | "b";
# foo は「a」か「b」を等確率で生成する
% foo "x";
# foo によって文字列を生成した後に「x」を結合した文字列を生成する
# 結果的に「ax」か「bx」が等確率で生成される
```

連続パターンの要素が選択パターンか複合パターンの場合、前後を `(` と `)` で囲む必要があります。
```zatlin
% ("a" | "b") "x" ("c" | "d");  # 3 つの要素からなる連続パターン
# 「axc」か「axd」か「bxc」か「bxd」が等確率で生成される
```

### 後方参照パターン
連続パターンの中で `&` の後に整数を続けた記号を書くことで、後方参照することができます。
例えば、`&1` と書くと、連続パターンの中の 1 番目のパターンが生成した文字列と同一の文字列が生成されます。
```zatlin
foo = "a" | "b";
% foo &1;
# 「aa」か「bb」が等確率で生成される
```

なお、後方参照が参照するパターンは、その後方参照自身が置かれている箇所より前になければなりません。
例えば、`&2` は 2 番目のパターンを参照するので、`&2` 自身は連続パターンの中の 3 番目以降にしか置くことができません。
それ以外の場所に後方参照が置かれた場合、エラー #2001 が発生します。
```zatlin
foo = "a" | "b";
% foo &2 ("x" | "y");  # エラー
```

### 選択パターン
パターンを `|` で区切って並べると選択パターンになります。
選択パターンは、それを構成するパターンのうちいずれかを等確率で 1 つ選び、選ばれたパターンに従って生成した文字列を生成します。
```zatlin
% "a" | "b" | "c";
# 「a」か「b」か「c」が等確率で生成される
```

選択パターンを構成するパターンの後に数値を記すことで、その数値の分だけそのパターンが選択されやすくなります。
例えば、`2` を記しておくと、そのパターンが選択される確率が他のものの 2 倍になります。
また、`0.5` を記しておくと、そのパターンが選択される確率が他のものの 0.5 倍になるので、逆に他のパターンに比べて選択されにくくなります。
```zatlin
% "a" 3 | "b" 2 | "c";
# 「a」は 3 倍,「b」は 2 倍生成されやすくなる
# 結果的に 1/2 の確率で「a」, 1/3 の確率で「b」, 1/6 の確率で「c」が生成される
```

### 複合パターン
選択パターンの後に `-` に続いて別のパターンを記すことで、複合パターンを作ることができます。
複合パターンは、まず前半の選択パターンに従って文字列を生成しますが、その文字列が `-` の後のパターンが生成し得る文字列を含んでいる場合、もう一度前半の選択パターンから文字列を生成し直します。
結果的に、`-` の後のパターンが生成し得る文字列を含む文字列が、この複合パターン全体によって生成される文字列から除外されることになります。
そのため、`-` の後に書かれたパターンは「除外パターン」と呼ばれます。
```zatlin
% "abc" | "pqr" | "xyz" - "p";
#「abc」と「pqr」と「xyz」のいずれかが等確率で生成された後で
# それが「p」を含む「pqr」だった場合はもう一度生成し直す
# 結果的に「pqr」はこのパターンから生成されずに「abc」か「xyz」が等確率で生成される
```

選択パターン部分からの生成し直しは、最大で 100 回まで行われます。
100 回生成し直しても除外パターン部分が生成し得ない文字列が得られなかった場合、エラー #2000 が発生します。
これは、例えばあり得るパターンが全て除外されてしまっているときに起こります。
```zatlin
% "ab" | "ac" | "bc" - "a" | "c";
# 前半部分で生成され得る「ab」か「ac」か「bc」はいずれも「a」と「c」を含んでいる
# したがって常に再生成が試みられる
# 結果的に複合パターンからの生成に失敗してエラーになる
```

また、除外されない文字列が生成される確率が非常に低い場合も、エラー #2000 が発生して失敗に終わる可能性があります。
```zatlin
% "a" 1000000 | "b" 1 - "a";
# 1/1000001 の確率で除外設定されていない「b」が生成され得る
# しかし「b」の確率が非常に低いので 100 回の試行ではほとんど生成されない
# 結果的にほとんど必ずエラーになる
```

### 境界パターン
複合パターンの除外パターン部分では、`^` という特殊な記号を使うことができます。
`^` が連続パターンの先頭に書かれた場合は、その連続パターンが生成し得る文字列から始まる文字列のみが除外されます (`^` がないと該当パターンが生成し得る文字列が途中に含まれているものが全て除外される)。
```zatlin
% "ab" | "ba" | "ca" - ^ "a" | "c";
# 「a」で始まるものか「c」を含むものが除外される
# 結果的に「ba」だけが生成される
```

`^` が連続パターンの末尾に書かれた場合は、その連続パターンが生成し得る文字列で終わる文字列のみが除外されます。
```zatlin
% "ab" | "ba" | "ca" - "a" ^;
# 「a」で終わるものが除外される
# 結果的に「ab」だけが生成される
```

`^` が連続パターンの先頭にも末尾に書かれた場合は、その連続パターンが生成し得る文字列と完全に一致する文字列のみが除外されます。
```zatlin
% "a" | "aa" | "aaa" - ^ "a" ^;
# 「a」のみが除外される
# 結果的に「aa」と「aaa」が等確率で生成される
```

この `^` は、生成されたパターンが除外されるかどうか調べるときに、文字列の前後の境界にマッチすると考えると分かりやすいかもしれません。

複合パターンの除外部分には任意のパターンが書けるので、もちろん変数パターンも使えます。
そこで、`^` を含むパターンを変数に定義しておいて、その変数を複合パターンの除外パターン部分で使うこともできます。
```zatlin
start_with_vowel = ^ ("a" | "e" | "i" | "o" | "u");
% "abc" | "def" | "ijk" | "uvw" - start_with_vowel;
# 「def」のみが生成される。
```

なお、`^` は連続パターンの先頭か末尾にしか置くことはできません。
それ以外の場所 (連続パターンの内部など) に置くと構文エラーになります。
```zatlin
% "abc" | "bac" | "cab" - "a" ^ "c";  # 構文エラー
```

なお、`^` を複合パターンの除外部分以外にも書くこともできますが、その場合は単に無視されます。
```zatlin
% ^ "a" | "b" "c" ^;
# 「a」と「bc」が等確率で生成される
```

## より複雑な例
```zatlin
# 母音
V = "a" 5 | "e" 3 | "i" 2 | "o" 3 | "u" 2;
# 子音
sz = "s" | "z"; td = "t" | "d"; kg = "k" | "g"; fv = "f" | "v";
C = sz 3 | td 3 | kg 3 | fv 3 | ("n" | "h") 2;
# 半母音＋母音
# 「yi」と「wu」と「wo」は半母音なしと区別が難しいので除外
SV = V 5 | ("y" | "w") V - "yi" | "w" ("u" | "o");
# 音節
syll_vowel = V 3 | SV C 2;
syll_cons = C SV 5 | C SV C 2 | C SV C C 3 | C C SV 5 | C C SV C 2 | C C SV C C 3;
syll_first = syll_vowel | syll_cons 3;
syll_rest = syll_cons;
# 発音が難しい綴り
# 「h」で終わる単語や調音位置が同じ文字の連続など
# 後で除外設定のために使う
hard_h = C "h" | "h" C | "h" ^;
hard_cons = sz sz | td td | kg kg | fv fv | (("n" | "h") &1);
hard = hard_h | hard_cons;
# 単語
word = syll_first ("" | syll_rest 3 | syll_rest syll_rest 5) - hard;
# メインパターン
% word;
```
以下は生成例です。
上の欄の右端にある「試す」から実際に Zatlin を実行することも可能なので、試してみてください。
```
feve, neksvzutkek, sdo, si, otsokz, vonevsyad, o, usa,
ozuho, vgedavuf, fuzkoz, insgozvat, e, zvofs, aga, sanse,
efdi, okisn, fakvkok, onvekyu, sgekvisnyu, duztfti, dkostwi, vovso,
adsofye, de, fkak, kvwidsaftne, dadve, fazuzyo, kosguknagv, gatskzakwa,
fakve, faswefak, fkahego, fe, azfkiftsfevz, hyadise, gzesihof, azutza,
gvyekfe, tof, nosidziz, dfutafa, navde, sasonsfid, atzadev, zgakndfuzv
```